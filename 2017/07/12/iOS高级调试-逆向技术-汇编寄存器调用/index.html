<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="前言本文翻译自Assembly Register Calling Convention Tutorial">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS高级调试&amp;逆向技术-汇编寄存器调用">
<meta property="og:url" content="http://yoursite.com/2017/07/12/iOS高级调试-逆向技术-汇编寄存器调用/index.html">
<meta property="og:site_name" content="朝元的博客">
<meta property="og:description" content="前言本文翻译自Assembly Register Calling Convention Tutorial">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/DebuggingBookFreeTut_1-feature.png">
<meta property="og:image" content="http://yoursite.com/images/xcode_assembly-650x212.png">
<meta property="og:image" content="http://yoursite.com/images/xcode_arm_assembly-650x229.png">
<meta property="og:image" content="http://yoursite.com/images/registers.png">
<meta property="og:image" content="http://yoursite.com/images/xcode_symbolic.png">
<meta property="og:image" content="http://yoursite.com/images/touch_outside.png">
<meta property="og:image" content="http://yoursite.com/images/red_console.png">
<meta property="og:image" content="http://yoursite.com/images/yay_debugging.png">
<meta property="og:image" content="http://yoursite.com/images/yay_debugging2.png">
<meta property="og:updated_time" content="2017-07-13T10:25:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS高级调试&amp;逆向技术-汇编寄存器调用">
<meta name="twitter:description" content="前言本文翻译自Assembly Register Calling Convention Tutorial">
<meta name="twitter:image" content="http://yoursite.com/images/DebuggingBookFreeTut_1-feature.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/12/iOS高级调试-逆向技术-汇编寄存器调用/"/>





  <title>iOS高级调试&逆向技术-汇编寄存器调用 | 朝元的博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">朝元的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/12/iOS高级调试-逆向技术-汇编寄存器调用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="朝元">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝元的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS高级调试&逆向技术-汇编寄存器调用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-12T10:58:34+08:00">
                2017-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文翻译自<a href="https://www.raywenderlich.com/161938/assembly-register-calling-convention-tutorial" target="_blank" rel="noopener">Assembly Register Calling Convention Tutorial </a></p>
<a id="more"></a>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p><img src="../../../../images/DebuggingBookFreeTut_1-feature.png" alt="DebuggingBookFreeTut_1-feature"></p>
<p>通过本教程，你会可以看到CPU使用的寄存器，并探索和修改传递给函数调用的参数。还将学习常见的苹果计算机架构以及如何在函数中使用寄存器。这就是所谓架构的调用约定。 </p>
<p>了解汇编是如何工作的，以及特定架构调用约定是如何工作是一项极其重要的技能。它可以让你在没有源码的情况下，观察和修改传递给函数的参数。此外，因为源码存在不同或未知名称的变量情况，所以有时候更适合使用汇编。 </p>
<p>比如说，假设你总想知道调用函数的第二个参数，不管参数的名称。汇编知识为你提供一个很好的基础层来操作和观察函数中的参数。</p>
<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>等等,汇编是什么？ </p>
<p>你有没有停在一个没有源码的函数中，你会看到一系列内存地址，后面跟着一些吓人的短命令？你拥抱成球轻声在耳边私语告訴自己你从來不看这些东西？嗯…这些东西就是所谓的汇编！</p>
<p>这是一张Xcode里的回溯图片，它展示了模拟器里的汇编函数。 </p>
<p><img src="../../../../images/xcode_assembly-650x212.png" alt="xcode_assembly-650x212"></p>
<p>看上面的图片，这个汇编可以分成几个部分部分。每一行的汇编指令都包含一个操作码，它可以被认为是非常简单的计算机指令。 </p>
<p>那么操作码看起来像什么样子呢？一个操作码执行计算机中的一个简单的任务的指令。比如，思考下面的汇编代码段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pushq   %rbx  </span><br><span class="line">subq    $0x228, %rsp  </span><br><span class="line">movq    %rdi, %rbx</span><br></pre></td></tr></table></figure>
<p>在这个汇编块中，你会看到三个<code>操作码</code>，<code>pushq</code>，<code>subq</code> 和 <code>movq</code>。思考下这些操作码执行的动作。操作码后面是来源和目标的标签。这些就是操作码行为项。 </p>
<p>在上一个例子中，有一系列<code>寄存器</code> ，分别是 <code>rbx</code> ，<code>rsp</code> 和 <code>rdi</code>，在每个<code>%</code>后面的都称为寄存器。 </p>
<p>另外，你可以找到16进制的常量如<code>0x228</code>。这个<code>$</code>后面的常量都为绝对数。 </p>
<p>目前都不需要知道这些代码在做什么，因为你首先需要了解函数的寄存器和调用约定。</p>
<blockquote>
<p><strong>Note：</strong>在上面例子中，寄存器和常量之前有一堆<code>%</code>和<code>$</code>。这是一种怎样的表达方式。然而，有两种主要方式展示汇编 。第一种是<code>Intel</code>汇编，第二种是<code>AT&amp;T</code>汇编。</p>
</blockquote>
<blockquote>
<p>默认的，苹果反汇编工具库显示的是AT&amp;T格式。正如上面例子中，虽然这是一种很好的格式，但可以肯定它有一点困难。</p>
</blockquote>
<h1 id="x86-64-vs-ARM64"><a href="#x86-64-vs-ARM64" class="headerlink" title="x86_64 vs ARM64"></a>x86_64 vs ARM64</h1><p>作为apple平台的开发者，当你学习汇编时，将会处理两种主要的汇编架构：<code>x86_64</code> 架构和 <code>ARM64</code> 架构，x86_64可能是你的macOS计算机架构，除非你运行在比较旧的电脑上。 x86_64是一种<code>64-bit</code>的架构，意味着每个地址可以容纳64个1和0。另外,老的苹果电脑使用<code>32-bit</code>架构，但苹果在2010年已经停止生产32位的计算机了。程序运行在MacOS下可以兼容64位，包括模拟器程序。也就是说，即使你是x86_64的MacOS,它仍然可以运行32位程序。</p>
<p>如果你对工作的硬件的架构表示任何的疑惑，可以在终端运行如下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -m</span><br></pre></td></tr></table></figure>
<p>ARM64 架构使用在移动设备如iPhone，控制电量消耗是最重要的。<br>ARM 强调电源保护，所以它减少了一些操作码，这助于在复杂汇编指令下的能源消耗减少。这对你来说是个好消息，因为在ARM架构上学习的指令更少。 </p>
<p>下面是前面显示的相同方法的截图，这一次是跑在iPhone 7的ARM64位汇编下: </p>
<p><img src="../../../../images/xcode_arm_assembly-650x229.png" alt="xcode_arm_assembly"></p>
<p>在他们的这么多设备中，但后来都移动到 64 位 ARM 处理器。32位设备几乎过时了，因为 Apple 已经通过各种 iOS 版本淘汰了他们。比如iPhone 4s 是32 位设备已经不支持 iOS 10。在32位 iPhone 系列中剩下的只有 iPhone 5 支持 iOS 10。 </p>
<p>有意思的是，所有的 Apple 手表目前都是 32 位。这很可能是因为 32 位 ARM CPU 通常比它们的 64 位兄弟有更小的功率。这对手表很重要，因为电池很小。</p>
<h1 id="x86-64-寄存器调用约定"><a href="#x86-64-寄存器调用约定" class="headerlink" title="x86_64 寄存器调用约定"></a>x86_64 寄存器调用约定</h1><p>你的CPU使用一组寄存器处理运行中的数据。这些是存储设备，就像你计算机里的内存。然而它们的位于CPU本身，非常接近CPU部分。所以CPU访问它们的时候非常快。 </p>
<p>大多数指令涉及一个或多个寄存器，并执行操作。就像写寄存器到内存中，读内存的内容到寄存器，或在两个寄存器上执行算术操作(加减等等)。</p>
<p>在<code>x64</code>(这里开始，x64是x86_64的缩写)，有16个通用寄存器的机器用来操纵数据。 </p>
<p>这些寄存器分别是 <code>RAX</code>，<code>RBX</code>，<code>RCX</code>，<code>RDX</code>，<code>RDI</code>，<code>RSI</code>，<code>RSP</code> 和 <code>R8</code> 到 <code>R15</code>。你现在可能并不清楚这些名字的含意，但你很快就会探索这些重要的寄存器。 </p>
<p>当你在x64下调用函数，这种方式和使用寄存器，后面有非常具体的约定。这决定了函数的参数应该在哪里，在函数完成时函数的返回值在哪里。这很重要，因为用一个编译器编译的代码可以使用另一个编译器编译的代码。<br>举个例子，看一下下面这个 Object-C 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *name = @&quot;Zoltan&quot;;  </span><br><span class="line">NSLog(@&quot;Hello world, I am %@. I&apos;m %d, and I live in %@.&quot;, name, 30, @&quot;my father&apos;s basement&quot;);</span><br></pre></td></tr></table></figure>
<p>它有四个参数传递到NSLog函数调用，有些变量是直接访问的，有一个参数是定义在本地变量中，然后引用参数在函数里。然而，通过汇编看代码时候，计算机不会关心变量的名称，它只关心内存中的地址。<br>下面的寄存器在x64汇编下作为函数调用时的参数。试着把这些内存提交他们到内存中，因为将来，你会经常使用这些内存。</p>
<ul>
<li>第一个参数：<code>RDI</code></li>
<li>第二个参数：<code>RSI</code></li>
<li>第三个参数：<code>RDX</code></li>
<li>第四个参数：<code>RCD</code></li>
<li>第五个参数：<code>R8</code></li>
<li>第六个参数：<code>R9</code></li>
</ul>
<p>如果超过六个参数，在函数里就会通过栈来访问额外的参数。 </p>
<p>返回到上面的OC例子中，你可以重新定义寄存器就像下面的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RDI = @&quot;Hello world, I am %@. I&apos;m %d, and I live in %@.&quot;;  </span><br><span class="line">RSI = @&quot;Zoltan&quot;;  </span><br><span class="line">RDX = 30;  </span><br><span class="line">RCX = @&quot;my father&apos;s basement&quot;;  </span><br><span class="line">NSLog(RDI, RSI, RDX, RCX);</span><br></pre></td></tr></table></figure>
<p>当<code>NSLog</code>函数开始，这些寄存器会包含适当的值。如上图所示。</p>
<p>不管如何，当函数序言(function prologue)(准备栈和寄存器的函数开始部分)完成执行，这些寄存器上的值很有可能就会改变。通常在代码不需要它们的时候，汇编将会重写这些值，或简单的丢弃引用。 </p>
<p>意味着当你离开函数时开始(通过stepping over,stepping in, or stepping out),你再也不能假设寄存器将保留你希望观察到的值，除非你实际看到汇编代码它正在做什么。 </p>
<p>这个函数调用严重影响你的调试(断点)策略，你是否想自动化任何类型的中断去探索，你应该停止在函数调用之前，以便检查或修改参数，而不是真正到达汇编里。</p>
<h1 id="Objective-C-和-寄存器"><a href="#Objective-C-和-寄存器" class="headerlink" title="Objective-C 和 寄存器"></a>Objective-C 和 寄存器</h1><p>寄存器使用具体的调用约定。你可以使用相同的知识应用在其它语言中。 </p>
<p>当 OC 执行方法内部，其实是通过一个具体的名为 objc_msgSend 的C函数来执行。这实际上函数有几种不同的类型，稍后再谈。这是消息转发的核心。第一个参数，objc_msgSend 引用发送消息的对象。然后是 selector，这是一个简单的char *指定的在对象上执行的函数名称。最后，objc_msgSend 采用可变参数在函数里。<br>让我们看个 iOS 环境上的实际例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIApplication sharedApplication];</span><br></pre></td></tr></table></figure></p>
<p>编译器会把代码转成如下伪代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id UIApplicationClass = [UIApplication class];  </span><br><span class="line">objc_msgSend(UIApplicationClass, &quot;sharedApplication&quot;);</span><br></pre></td></tr></table></figure></p>
<p>第一个参数引用是UIApplication类，紧接着是 sharedApplication 的selector。 </p>
<p>告诉参数的一个简单方法是检查selector的冒号。每个冒号代表跟随一个参数。 </p>
<p>这是另一个OC例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *helloWorldString = [@&quot;Can&apos;t Sleep; &quot; stringByAppendingString:@&quot;Clowns will eat me&quot;];</span><br></pre></td></tr></table></figure>
<p>编译器会转成如下伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *helloWorldString;  </span><br><span class="line">helloWorldString = objc_msgSend(@&quot;Can&apos;t Sleep; &quot;, &quot;stringByAppendingString:&quot;, @&quot;Clowns will eat me&quot;);</span><br></pre></td></tr></table></figure>
<p>第一个参数是实例<code>NSString(@&quot;Can&#39;t Sleep; &quot;)</code>，紧接着是selector,最后是一个参数，也是<code>NSString</code>实例。<br>使用<code>objc_msgSend</code>知识，你可以使用x64寄存器帮助探索上下文，这是一种捷径。</p>
<h1 id="理论到实际"><a href="#理论到实际" class="headerlink" title="理论到实际"></a>理论到实际</h1><p>你可以下载教程项目在<a href="https://koenig-media.raywenderlich.com/uploads/2017/05/AdvancedDebugging_ch10_tutorial_starter.zip" target="_blank" rel="noopener">这里</a> </p>
<p>在这章，你将使用项目提供的教程资源bundle调用寄存器，打开项目在Xcode里，并运行它。 </p>
<p><img src="../../../../images/registers.png" alt="registers"></p>
<p>这是一个相当简单的应用程序，仅仅显示x64寄存器的内容。重要的是要注意，这个应用程序不能在任何给定的时刻显示寄存器的值，它只能显示在指定函数调用时寄存器的值。意味着当函数使用寄存器的值进行调用时，你不会看到太多寄存器变化的值。 </p>
<p>现在你将会理解macOS应用程序功能行为的寄存器，创建一个<code>NSViewController</code>的<code>viewDidLoad</code>方法符号断点。推荐使用”NS”代替”UI”，因为你正在运行Cocoa程序。 </p>
<p><img src="../../../../images/xcode_symbolic.png" alt="xcode_symbolic"></p>
<p>构建然后返回应用程序，第一次断点停止，在LLDB控制台里输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read</span><br></pre></td></tr></table></figure>
<p>在执行状态暂停，会显示主要寄存器的列表。无论如何，这些信息在多了。你应该有选择地输出寄存器和修复他们成为OC对象。</p>
<p>如果你重新调用，<code>-[NSViewController viewDidLoad]</code> 将会转换成如下汇编伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RDI = UIViewControllerInstance  </span><br><span class="line">RSI = &quot;viewDidLoad&quot;  </span><br><span class="line">objc_msgSend(RDI, RSI)</span><br></pre></td></tr></table></figure>
<p>记住x64调用约定，了解 objc_msgSend 的执行，你可以找到被加载具体的<code>NSViewController</code>实例。 </p>
<p>在LLDB控制台输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $rdi</span><br></pre></td></tr></table></figure>
<p>你将会得到输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Registers.ViewController: 0x6080000c13b0&gt;</span><br></pre></td></tr></table></figure></p>
<p>这将会输出隐藏在RDI寄存器中的<code>NSViewController</code>引用，你知道，对于函数这是第一个参数。 </p>
<p>在LLDB里，重要的是<code>$</code>前缀是寄存器，所以LLDB知道你想要寄存器的值，而不是当前源码范围内的变量。是的，这与在反汇编视图中看的汇编不同！有点恼人，是吧？</p>
<blockquote>
<p><strong>Note</strong>：细心观察当你OC停止方法时，你从没看到 <code>objc_msgSend</code> 在LLDB的回溯里，这是因为<code>objc_msgSend</code>这类函数执行是 <code>jmp</code> ,或是是跳转操作码的汇编指令。这个意思是<code>objc_msgSend</code>行动就像跳转函数，一但OC代码开始运行，所有有关 <code>objc_msgSend</code> 历史的栈都会被优化。这种优化称为<code>尾部调用优化</code>.</p>
</blockquote>
<p>尝试输出<code>RSI</code>寄存器，希望包含被调用的selector，输出以下内容在LLDB中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $rsi</span><br></pre></td></tr></table></figure></p>
<p>不幸的是，你获得了无效输出信息，看起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">140735181830794</span><br></pre></td></tr></table></figure></p>
<p>为什么是这样？ </p>
<p>OC selector本质上是<code>char *</code>。这意味着，像所有的C类型，LLDB并不知道应用什么样式来展现数据。结果，你必须明确地转换成你想要的数据类型。 </p>
<p>尝试转换成正确的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (char *)$rsi</span><br></pre></td></tr></table></figure></p>
<p>现在你得到了你的预期：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;viewDidLoad&quot;</span><br></pre></td></tr></table></figure></p>
<p>当然，你也可以输出Selector类型，产生同样的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po (SEL)$rsi</span><br></pre></td></tr></table></figure></p>
<p>现在，是时候探索OC方法的参数了，从你停止在<code>viewDidLoad</code>，你可以安全的假设<code>NSView</code>实例已经被加载了。下面我们来看一下NSView的父类<code>NSResponder</code>的一个比较有趣的方法<code>mouseUp:</code>。 </p>
<p>在LLDB，创建一个<code>NSResponder</code>的<code>mouseUp:</code>断点，然后继续执行。如果你不记得怎么做，这里有个命令行你可能需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) b -[NSResponder mouseUp:]</span><br><span class="line">(lldb) continue</span><br></pre></td></tr></table></figure></p>
<p>现在，点击应用程序窗口，确认点击是NSScrollView的外面，否则你的点击会被NSScrollView捕获，<code>-[NSResponder mouseUp:]</code>断点将不会触发。</p>
<p> <img src="../../../../images/touch_outside.png" alt="touch_outside"></p>
<p>当用鼠标或触控板点击，LLDB会停止在mouseUp:断点。通过输出接下来的内容到控制台，来输出引用的NSResponder：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $rdi</span><br></pre></td></tr></table></figure></p>
<p>接着你会得到类似地输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;NSView: 0x608000120140&gt;</span><br></pre></td></tr></table></figure></p>
<p>无论如何，这是一个有趣的selector，它包含冒号在里面，意味着他有参数可以探索！输出以下内容到LLDB控制台中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $rdx</span><br></pre></td></tr></table></figure></p>
<p>你将获得有关NSEvent的描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSEvent: type=LMouseUp loc=(351.672,137.914) time=175929.4 flags=0 win=0x6100001e0400 winNum=8622 ctxt=0x0 evNum=10956 click=1 buttonNumber=0 pressure=0 deviceID:0x300000014400000 subtype=NSEventSubtypeTouch</span><br></pre></td></tr></table></figure>
<p>为什么称它为<code>NSEvent?</code>嗯，你可以看在线文档关于<code>-[NSResponder mouseUp:]</code>或者你可以简单使用OC来获得类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [$rdx class]</span><br></pre></td></tr></table></figure>
<p>很酷，是吧？</p>
<p>有时候使用寄存器和断点是很有用的，以便获取已经内存中的对象引用。<br>举例来说，如果你想把前置的NSWindow变成红色，但你代码中没有此视图的引用，同时你也不想重新编译任何代码的改变？你可以简单的创建一个断点，从寄存器和操作实例对象来获得引用。你可以尝试着改变主窗口成红色。</p>
<blockquote>
<p><strong>Note：</strong>尽管每个 <code>NSResponder</code> 实现了 <code>mouseDown:</code> ， <code>NSWindow</code> 通过继承重载此方法。你可以不通过源码方式找出所有实现了<code>mouseDown:</code>方法的类，确定哪些继承了 <code>NSResponder</code> 的类。 举个输出所有实现了 <code>mouseDown:</code> 的Objective-C类的例子： <code>image lookup -rn &#39;\ mouseDown:</code></p>
</blockquote>
<p>首先移除所有的之前的断点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) breakpoint delete</span><br><span class="line">About to delete all breakpoints, do you want to do that?: [Y/n]</span><br></pre></td></tr></table></figure></p>
<p>然后输出以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) breakpoint set -o -S &quot;-[NSWindow mouseDown:]&quot;</span><br><span class="line">(lldb) continue</span><br></pre></td></tr></table></figure></p>
<p>这会设置一个断点，它只触发一次 —— 一次性断点。</p>
<p>点击应用程序，点击之后立即就会触发断点。然后输入以下在LLDB控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [$rdi setBackgroundColor:[NSColor redColor]]</span><br><span class="line">(lldb) continue</span><br></pre></td></tr></table></figure></p>
<p>恢复断点，NSWindow就会变成红色！</p>
<p><img src="../../../../images/red_console.png" alt="red_console"></p>
<h1 id="Swift-和-寄存器"><a href="#Swift-和-寄存器" class="headerlink" title="Swift 和 寄存器"></a>Swift 和 寄存器</h1><p>当在Swift探索寄存器的时候，相比较OC而言，你将会遇到两个方面的困难。</p>
<ol>
<li>首先，寄存器<code>不能</code>用在Swift调试上下文。意味着你无论想要获得什么数据，你得使用OC调试上下文输出寄存器。记住你可以使用 <code>expression -l objc -O --</code>命令。幸运的是 <code>register read</code> 命令是可以在Swift环境中使用的。</li>
<li>第二，Swift相比较OC并不是动态语言。事实上，有时候最好假设Swift像C语言，除了有一个非常非常暴躁和专横的编译器。如果你有内存地址，你需要明确地转换成你期望的对象，否则，Swift调试环境并不知道解释内存地址。</li>
</ol>
<p>也就是说，Swift也使用了相同的寄存器调用约定。无论如何，这是一个非常重要的不同点。当Swift调用函数，它不需要使用<code>objc_msgSend</code>,除非你标记方面为<code>dynamic</code>。意味着Swift调用函数，之前RSI寄存器关联的是selector，而实际上是函数的第二个参数。 </p>
<p>理论足够了–是时候该行动了。 </p>
<p>在Registers项目中，导航到<code>ViewController.swift</code>，然后增加相关的函数在类里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func executeLotsOfArguments(one: Int, two: Int, three: Int,  </span><br><span class="line">                            four: Int, five: Int, six: Int,</span><br><span class="line">                            seven: Int, eight: Int, nine: Int,</span><br><span class="line">                            ten: Int) &#123;</span><br><span class="line">        print(&quot;arguments are: \(one), \(two), \(three), \(four), \(five), \(six), \(seven), \(eight), \(nine), \(ten)&quot;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，在 <code>viewDidLoad</code> 中，调用该函数与相应的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;  </span><br><span class="line">  super.viewDidLoad()</span><br><span class="line">  self.executeLotsOfArguments(one: 1, two: 2, three: 3, four: 4,</span><br><span class="line">                              five: 5, six: 6, seven: 7,</span><br><span class="line">                              eight: 8, nine: 9, ten: 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>放置一个断点在 <code>executeLotsOfArguments</code> 函数调用的行上，然后调试器会停在最开始函数的地方。这很重要，否则在函数执行的时候寄存器将会被破坏。</p>
<p>然后移除之前的设置在<code>-[NSViewController viewDidLoad]</code>断点。</p>
<p>构建和运行app，然后等待<code>executeLotsOfArguments</code>断点让程序暂停。 </p>
<p>再次，一种好的方式是开始调查输出寄存器列表，在LLDB中，输出以下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read -f d</span><br></pre></td></tr></table></figure></p>
<p>这会输出寄存器并使用数字格式<code>-f d</code>显示。输出看起来是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">General Purpose Registers:  </span><br><span class="line">       rax = 7</span><br><span class="line">       rbx = 9</span><br><span class="line">       rcx = 4</span><br><span class="line">       rdx = 3</span><br><span class="line">       rdi = 1</span><br><span class="line">       rsi = 2</span><br><span class="line">       rbp = 140734799801424</span><br><span class="line">       rsp = 140734799801264</span><br><span class="line">        r8 = 5</span><br><span class="line">        r9 = 6</span><br><span class="line">       r10 = 10</span><br><span class="line">       r11 = 8</span><br><span class="line">       r12 = 107202385676032</span><br><span class="line">       r13 = 106652628550688</span><br><span class="line">       r14 = 10</span><br><span class="line">       r15 = 4298620128  libswiftCore.dylib`swift_isaMask</span><br><span class="line">       rip = 4294972615  Registers`Registers.ViewController.viewDidLoad () -&gt; () + 167 at ViewController.swift:16</span><br><span class="line">    rflags = 518</span><br><span class="line">        cs = 43</span><br><span class="line">        fs = 0</span><br><span class="line">        gs = 0</span><br></pre></td></tr></table></figure></p>
<p>正如你看到的，寄存器跟随x64位的调用约定。<code>RDI</code>，<code>RSI</code>，<code>RDX</code>，<code>RCX</code>，<code>R8</code> 和 <code>R9</code> 持有了你的六位参数。</p>
<p>你还可能注意到其他参数存储在其它寄存器中。虽然这是真的，但它只是代码的剩余部分，它为其余参数设置到栈上。记住，第六个参数之后的都在栈上。</p>
<h1 id="RAX，保存返回值的寄存器"><a href="#RAX，保存返回值的寄存器" class="headerlink" title="RAX，保存返回值的寄存器"></a>RAX，保存返回值的寄存器</h1><p>等等–还有更多！到目前为止，你已经了解如何在函数中调用六个寄存器，但是有关返回值的呢？</p>
<p>幸运的是，只有一个函数返回值的寄存器：<code>RAX</code>。返回到 <code>executeLotsOfArguments</code> 然后修改函数返回为 <code>String</code> ,像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func executeLotsOfArguments(one: Int, two: Int, three: Int,  </span><br><span class="line">                            four: Int, five: Int, six: Int,</span><br><span class="line">                            seven: Int, eight: Int, nine: Int,</span><br><span class="line">                            ten: Int) -&gt; String &#123;</span><br><span class="line">    print(&quot;arguments are: \(one), \(two), \(three), \(four), \(five), \(six), \(seven), \(eight), \(nine), \(ten)&quot;)</span><br><span class="line">    return &quot;Mom, what happened to the cat?&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>viewDidLoad</code>，修改函数调用接收并忽略字符串的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;  </span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    let _ = self.executeLotsOfArguments(one: 1, two: 2,</span><br><span class="line">          three: 3, four: 4, five: 5, six: 6, seven: 7,</span><br><span class="line">          eight: 8, nine: 9, ten: 10)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建断点在 <code>executeLotsOfArguments</code> 的任意地方。再次构建和运行。然后在函数里等待执行到暂停。下一步，输出以下到LLDB控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) finish</span><br></pre></td></tr></table></figure></p>
<p>它会完成执行当前函数并再次暂停调试器。此刻，函数返回值应该已经在 <code>RAX</code>。输出以下内容在LLDB中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read rax</span><br></pre></td></tr></table></figure></p>
<p>你会得到相似的结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rax = 0x0000000100003760  &quot;Mom, what happened to the cat?&quot;</span><br></pre></td></tr></table></figure></p>
<p>找到了！你返回的值！</p>
<p>了解返回值在 <code>RAX</code> 中是非常重要的，你将会在下个段落写函数的调试脚本。</p>
<h1 id="通过寄存器改变返回值"><a href="#通过寄存器改变返回值" class="headerlink" title="通过寄存器改变返回值"></a>通过寄存器改变返回值</h1><p>为了巩固对寄存器的理解，你将修改已编译应用程序中的寄存器。</p>
<p>关闭Xcode和Registers项目。打开终端窗口然后运行iPhone 7模拟器，像下面这样输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xcrun simctl list </span><br><span class="line">``` </span><br><span class="line">你会得到一个很长的设备列表，找到最后一个iOS版本的模拟器。在下面找到iPhone 7设备。看起来像是这样：</span><br></pre></td></tr></table></figure></p>
<p>iPhone 7 (269B10E1-15BE-40B4-AD24-B6EED125BC28) (Shutdown)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个UUID你将会在后面用到。使用下面命令打开模拟器并替换你的UUID：</span><br></pre></td></tr></table></figure></p>
<p>open /Applications/Xcode.app/Contents/Developer/Applications/Simulator.app –args -CurrentDeviceUDID 269B10E1-15BE-40B4-AD24-B6EED125BC28<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">确认模拟器已经被运行，并到主屏幕中。你可以通过快捷键``Command + Shift + H``到主屏幕。一旦模拟器运行完成。在终端窗口后面写上如下命令设置到SpringBoard程序：</span><br></pre></td></tr></table></figure></p>
<p>lldb -n Spring Board<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个把正在iOS模拟器中运行的SpringBoard实例，绑定到LLDB上！SpringBoard是一个在iOS上控制主屏幕的应用程序。</span><br><span class="line"></span><br><span class="line">输入如下命令在LLDB：</span><br></pre></td></tr></table></figure></p>
<p>(lldb) p/x @”Yay! Debugging”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">你会获得相似的输出：</span><br></pre></td></tr></table></figure></p>
<p>(__NSCFString *) $3 = 0x0000618000644080 @”Yay! Debugging!”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">记录下这个新创建的NSString实例的内存引用地址，你马上就会用到它。现在创建一个断点在``UILabel``的``setText:``方法：</span><br></pre></td></tr></table></figure></p>
<p>(lldb) b -[UILabel setText:]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下一步输入以下：</span><br></pre></td></tr></table></figure></p>
<p>(lldb) breakpoint command add<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLDB变成支持多行的编辑模式。这个命令让你增加额外的命令当你想命中断点时来执行。输入以下，并替换内存地址，像这样：</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>po $rdx = 0x0000618000644080<br>continue<br>DONE<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">回过头来看一下刚刚做的事情，你已经创建了一个断点在 ``UILabel`` 的 ``setText:`` 方法上。当此方法被命中，你会替换 ``RDX`` —第三个参数—不同的字符串实例``&quot;Yay!Debugging!&quot;``。</span><br><span class="line"></span><br><span class="line">恢复调试使用``continue``命令：</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>(lldb) continue<br><code>`</code><br>尝试探索SpringBoard模拟器app，会看到文本内容发生改变。划动手指从下往上拉出控制中心。然后观察改变： </p>
<p><img src="../../../../images/yay_debugging.png" alt="yay_debugging"></p>
<p>尝试浏览其它新弹出的地方，因为这可能会使视图被延迟加载，导致断点行动被命中。 </p>
<p><img src="../../../../images/yay_debugging2.png" alt="yay_debugging2"></p>
<p>虽然这可能看起来很酷的编程技术，提供了一种在有限的寄存器和汇编知识情况下，没有源码就可以产生巨大的变化。 从调试观点来看这很有用，你可以快速在视觉上进行验证，当<code>-[UILabel setText:]</code>在SpringBoard应用执行和运行在断点条件下去找精确的代码行去设置指定UILabel的文本。 </p>
<p>继续这个想法，有些 <code>UILabel</code> 实例的文本并没有改变也告诉你一些事情。比如说，<code>UIButton</code>的文本并没有改变。也许 UILabel 的 setText:在早期就被调用过？或者可能开发SpringBoard程序的开发者选择使用<code>setAttributtedText:</code>来代替？或者他们使用还未公开给第三方开发者的私有函数？ </p>
<p>正如你看到的，使用和操作寄存器可以提供给你很多的观察力，去了解应用程序的函数。</p>
<p>何去何从？<br>好了！这篇文章很长，不是吗？坐下来休息一下喝杯饮料；你获得了它。 你可以下载完整的项目从这篇教程的<a href="https://koenig-media.raywenderlich.com/uploads/2017/05/AdvancedDebugging_ch10_tutorial_starter.zip" target="_blank" rel="noopener">这里</a>。</p>
<p>你学习了什么？</p>
<ul>
<li>架构定义调用约定了哪个指令哪位参数到函数和它返回的值被保存。</li>
<li>在Objective-C中，<code>RDI</code> 寄存器用来引用调用的对象，<code>RSI</code> 是selector,<code>RDX</code> 是首个参数等等。</li>
<li>在Swift中，RDI 是第一个参数，RSI第 二个参数，然后等等，只要Swift方法不使用动态分发(dynamic dispatch)。<br>-<code>RAX</code> 寄存器为函数返回值使用，不管你是用在用OC还是Swift。</li>
<li>当使用<code>$</code>打印寄存器的时候，确认当前环境是OC。</li>
</ul>
<p>你可以用寄存器做很多事情。尝试探索没有源码的app；这很有趣，为解决调试问题打下了良好的基础。 </p>
<p>尝试在iOS模拟器和地图的UIViewControllers一样出现使用汇编、智能的断点和断点命令。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/05/数据结构-树/" rel="next" title="数据结构 - 树">
                <i class="fa fa-chevron-left"></i> 数据结构 - 树
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/16/H.264 的 NAL 单元及码流结构/" rel="prev" title="H.264 的 NAL 单元及码流结构">
                H.264 的 NAL 单元及码流结构 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpeg"
               alt="朝元" />
          <p class="site-author-name" itemprop="name">朝元</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">39</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序言"><span class="nav-number">2.</span> <span class="nav-text">序言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#汇编"><span class="nav-number">3.</span> <span class="nav-text">汇编</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#x86-64-vs-ARM64"><span class="nav-number">4.</span> <span class="nav-text">x86_64 vs ARM64</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#x86-64-寄存器调用约定"><span class="nav-number">5.</span> <span class="nav-text">x86_64 寄存器调用约定</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Objective-C-和-寄存器"><span class="nav-number">6.</span> <span class="nav-text">Objective-C 和 寄存器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理论到实际"><span class="nav-number">7.</span> <span class="nav-text">理论到实际</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Swift-和-寄存器"><span class="nav-number">8.</span> <span class="nav-text">Swift 和 寄存器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RAX，保存返回值的寄存器"><span class="nav-number">9.</span> <span class="nav-text">RAX，保存返回值的寄存器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通过寄存器改变返回值"><span class="nav-number">10.</span> <span class="nav-text">通过寄存器改变返回值</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">朝元</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
